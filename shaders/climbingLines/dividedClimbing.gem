#version 330
#extension GL_EXT_geometry_shader4: enable

layout(points) in;
layout(line_strip, max_vertices = 2) out;


uniform int desiredDepth;
uniform sampler2D evalField;
uniform sampler2D oldEvalField;

in vec4 gVertex2[];
in float gWeight[];
in int gDepth[];

flat out float fWeight;
flat out int fPos;

uniform float lowerBorder;
uniform float stepWidth;
uniform float sideFactor;
uniform float old2NewZoom;

vec2 getTexCoordinates(vec2 screenCoordinates) {
	return ((screenCoordinates + 1.0) / 2.0);
}

vec2 getTexCoordinatesOld(vec2 screenCoordinates) {
	return (((screenCoordinates / old2NewZoom) + 1.0) / 2.0);
}

vec2 getCoords(vec2 pos) {
	vec2 texCoords = getTexCoordinates(pos);

	//cut at factor 2 for all (4x zoomed should be rendered smaller not have a higher radius)
	if (pos.x > -2.0f && pos.x < 2.0f && pos.y > -2.0f && pos.y < 2.0f) {


		if (texCoords.x > 0.98 || texCoords.x < 0.02 || texCoords.y > 0.98 || texCoords.y < 0.02) {
			//no texture information available return the original value
			if (old2NewZoom > 1.0f) {		
				texCoords = getTexCoordinatesOld(pos);
				if (texCoords.x > 1.0 || texCoords.x < 0.0 || texCoords.y > 1.0 || texCoords.y < 0.0) {
					//no texture information available return the original value
					return pos;
				} else {
					return texture(oldEvalField, texCoords).xy * old2NewZoom;
				}
			} else {
				return pos;
			}
		} else {
			//return the lookup bundling coordinates
			return texture(evalField, texCoords).xy;
		}

	}
}

void main(void) 
{

	int i = 0;
	float edgeWeight = 0.0f;

	if ((abs(gDepth[i]) <= desiredDepth) &&  //leaf or inner node we wish to display
	    (abs(gDepth[i]) == desiredDepth || gDepth[i] > 0)) { //joinDepth level or leaf node
	        
			edgeWeight = gWeight[i];
	}


	if (edgeWeight > 0) {  //draw the edge

		vec2 coords1 = getCoords(gl_PositionIn[i].xy);
		vec2 coords2 = getCoords(gVertex2[i].xy);

		if (coords1.y > coords2.y) {
			vec2 tmp = coords2;
			coords2 = coords1;
			coords1 = tmp;
		}

		//oe coords1.y <= coords2.y test angle

		vec3 dir = vec3((coords2 - coords1), 0);
		dir = dir * vec3(sideFactor, 1, 1); //strech it back

		float alpha = floor(degrees(acos(dot(dir, vec3(1, 0, 0)) / length(dir))));

		if (alpha == 180.0f) {
			alpha = 0.0f;
		}


		if (alpha >= lowerBorder && alpha < (lowerBorder + 4 * stepWidth)) {

			int pos;
			if (alpha < (lowerBorder + stepWidth)) {
				pos = 0;
			} else
			if (alpha < (lowerBorder + 2 * stepWidth)) {
				pos = 1;
			} else 
			if (alpha < (lowerBorder + 3 * stepWidth)) {
				pos = 2;
			} else {
				pos = 3;
			}

			gl_Position = vec4(coords1, 0, 1);
			fWeight = edgeWeight;
			fPos = pos;
			EmitVertex();

			gl_Position = vec4(coords2, 0, 1);
			fWeight = edgeWeight;
			fPos = pos;
			EmitVertex();

			//finish
			EndPrimitive();
		}
	}
}